# Obligatorisk oppgave 3 i Algoritmer og Datastrukturer

Denne oppgaven er en innlevering i Algoritmer og Datastrukturer. 
Oppgaven er levert av følgende student:
* Ylli Gashi, s364574, s364574@oslomet.no


# Oppgavebeskrivelse

I oppgave 1 så fikset jeg på legginn metoden. først trengte vi å ha rot til en node. Når vi legger inn en ny node så sammanligner vi foreldre noden med den nye veriden om verdien til den nye noden (barnet) er større så blir den høyre-barn ellers så blir den venstre-barn. om det ikke er noen node fra før så blir nye noden rotnoden. om det er eksisterende foreldre node så blir noden barnet til noden og barnet får koblingen med sin forelder ved q.venstre.forelder = q; når alt er gjort så økes antallet og returner true. 

I oppgave 2 så fikset jeg på antall(T verdi). vi starter på rotnoden blir varabel p som skal søke gjennom treet og så lenge p ikke er null så skal den bevege seg rundt. Det sammenlignes hvor mange forekomster det finnes av verdien som søkes. om tallet er større enn rotnoden så bevegs den til høyre eller til venstre om verdien er mindre enn rotnoden. Om en node er lik verdien så har vi funnet en forekomst, men for å se om det finnes flere av verdien så brukes p=p.høyre hvis en node forekommer så blir den plassert som høyre-barn som er grunnen at p=p.høyre blir brukt. Når hele treet er søkt så returnerer antall forekomster.  

I oppgave 3 så fikset jeg førstepostorden() ved å se om p har venstre barn så vil den gå nedover i treet helt til den siste noden ikke har barn. etter flere sjekk så vil vi finne første noden for postorden. For nestepostorden så sjekket vi om p er rotnoden som betyr at neste er null. de andre sjekkene ser etter om foreldre noden har høyrebarn, om den har så vil p bli foreldre noden og førstepostorden kjøres for å finne venstre barnet til p som resulterer til at vi finner neste noden i postorden.

I oppgave 4 så fikset jeg Postorden() ved å se om rotnoden er null så returner den. ellers så finner vi førstepostnode av roten og while(p!=null) / så lenge det er noder i treet så utfører vi oppgaven med p.verdi som blir skrevet ut i skjermen. så blir p neste node i postorden. For den rekursive metoden så sjekket vi igjen om p er null. videre så kaller vi på metoden igjen og inserter venstre barnet og etter det for høyre barnet og så skrive ut verdiene. om vi hadde oppgave imellom kallene så ville vi ha fått inOrder og hvis oppgave var på starten så ville det bli preOrder.

I oppgave 5 så fikset jeg serialize() ved å ha en arraylist og lage en deque og adda p inn i køen og listen så har det en while løkke som fortsetter til køen er tom. inni løkken så fjerns en verdi, og om det er flere noder så addes de i køen. når det blir addet en verdi i køen feks 4 så vil den bli addet til listen og den 4-en vil da bli slettet når while løkken kjøres igjen. treet blir lagt inn i arraylisten i nivå orden. da har vi opprettet arraylisten og nå skal deserialize fikses også. for deserialize så oppretter jeg et nytt tre og bruker en for løkke som går gjennom hele arrayet og legger inn hver node i arrayet til treet. når alt er ferdig så returner vi treet.

I oppgave 6 så fikset jeg fjern(T) ved å compere søke verdi med node verdi, finner vi den så blir p verdien, hvis vi ikke finner den så returnerer det false. etter det så har vi 4 tilfeller for fjerning. 1) det er bare rotnoden i treet som skal fjernes da blir rot null. 2) noden som skal fjernes har ingen barn. da må vi finne om p er et venstre barn eller høyre barn ved p.forelder.høyre==p / p.forelder.venstre==p hvis det er true så slettes feks. venstre barnet ved p.forelder.venstre=null; 3) dette tilfellet er at noden har forelder og et barn. det som skjer er at p sit barns forelder blir p sin forelder, men hvis p sin forlder er null så blir barnet den nye rotnoden. 4) tilfellet her er at p har 2 barn. siden vi skal fjerne p så må en av de 2 barna ta plassen til p. dette gjør vi ved at høyre barnet tar plassen siden det kan være duplikat eller nærmeste største i høyre subtre. så vi gjør førstepostorden på p sitt høyre subtre. Fjernalle(T) ser på samme måte som Antall(T) om det er flere forekomster så kaller vi fjernmetoden. for nullstill så er vi om antallet er null hvis det er så returnerer det en tom tree. den finner førstepostorden og sletter den og går videre til nestepostorden og sletter hver node til det ikke er flere noder, da har vi klart å nullstille treet. 
